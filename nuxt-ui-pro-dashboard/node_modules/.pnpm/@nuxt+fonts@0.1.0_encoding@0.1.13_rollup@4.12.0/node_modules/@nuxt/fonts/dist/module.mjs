import { useLogger, useNuxt, addDevServerHandler, defineNuxtModule, addTemplate, addBuildPlugin, resolvePath, resolveAlias } from '@nuxt/kit';
import jiti from 'jiti';
import { globby } from 'globby';
import { join, resolve, relative, extname } from 'pathe';
import { filename } from 'pathe/utils';
import { createRegExp, anyOf, not, wordBoundary } from 'magic-regexp';
import { withTrailingSlash, withLeadingSlash, hasProtocol, joinURL } from 'ufo';
import { $fetch, fetch } from 'ofetch';
import { hash } from 'ohash';
import { findAll, parse, walk } from 'css-tree';
import { getMetricsForFamily, generateFontFace as generateFontFace$1 } from 'fontaine';
import { createStorage } from 'unstorage';
import fsDriver from 'unstorage/drivers/fs';
import { createUnplugin } from 'unplugin';
import MagicString from 'magic-string';
import { transform } from 'esbuild';
import fsp from 'node:fs/promises';
import { lazyEventHandler, eventHandler, createError } from 'h3';
import chalk from 'chalk';
import { defu } from 'defu';
import fsDriver$1 from 'unstorage/drivers/fs-lite';

const providerContext = {
  rootPaths: [],
  registry: {}
};
const local = {
  async setup(_options, nuxt) {
    for (const layer of nuxt.options._layers) {
      const publicDir = join(layer.config.srcDir || layer.cwd, layer.config.dir?.public || "public");
      const possibleFontFiles = await globby("**/*.{ttf,woff,woff2,eot,otf}", {
        absolute: true,
        cwd: publicDir
      });
      providerContext.rootPaths.push(withTrailingSlash(publicDir));
      for (const file of possibleFontFiles) {
        registerFont(file);
      }
    }
    providerContext.rootPaths = providerContext.rootPaths.sort((a, b) => b.length - a.length);
    nuxt.hook("builder:watch", (event, relativePath) => {
      const path = resolve(nuxt.options.srcDir, relativePath);
      if (event === "add" && isFontFile(path)) {
        registerFont(path);
      }
      if (event === "unlink" && isFontFile(path)) {
        unregisterFont(path);
      }
    });
  },
  resolveFontFaces(fontFamily, defaults) {
    const fonts = [];
    for (const weight of defaults.weights) {
      for (const style of defaults.styles) {
        for (const subset of defaults.subsets) {
          const resolved = lookupFont(fontFamily, [weightMap[weight] || weight, style, subset]);
          if (resolved.length > 0) {
            fonts.push({
              src: resolved,
              weight,
              style
            });
          }
        }
      }
    }
    if (fonts.length > 0) {
      return {
        fonts
      };
    }
  }
};
const FONT_RE = /\.(ttf|woff|woff2|eot|otf)(\?[^.]+)?$/;
const NON_WORD_RE = /[^\w\d]+/g;
const isFontFile = (id) => FONT_RE.test(id);
const weightMap = {
  "100": "thin",
  "200": "extra-light",
  "300": "light",
  "400": "normal",
  "500": "medium",
  "600": "semi-bold",
  "700": "bold",
  "800": "extra-bold",
  "900": "black"
};
const weights = Object.entries(weightMap).flatMap((e) => e).filter((r) => r !== "normal");
const WEIGHT_RE = createRegExp(anyOf(...weights).groupedAs("weight").after(not.digit).before(not.digit.or(wordBoundary)), ["i"]);
const styles = ["italic", "oblique"];
const STYLE_RE = createRegExp(anyOf(...styles).groupedAs("style").before(not.wordChar.or(wordBoundary)), ["i"]);
const subsets = [
  "cyrillic-ext",
  "cyrillic",
  "greek-ext",
  "greek",
  "vietnamese",
  "latin-ext",
  "latin"
];
const SUBSET_RE = createRegExp(anyOf(...subsets).groupedAs("subset").before(not.wordChar.or(wordBoundary)), ["i"]);
function generateSlugs(path) {
  let name = filename(path);
  const weight = name.match(WEIGHT_RE)?.groups?.weight || "normal";
  const style = name.match(STYLE_RE)?.groups?.style || "normal";
  const subset = name.match(SUBSET_RE)?.groups?.subset || "latin";
  for (const slug of [weight, style, subset]) {
    name = name.replace(slug, "");
  }
  const slugs = /* @__PURE__ */ new Set();
  for (const slug of [name.replace(/[.][\w\d]*$/, ""), name.replace(/[._-][\w\d]*$/, "")]) {
    slugs.add([
      fontFamilyToSlug(slug.replace(/[\W._-]+$/, "")),
      weightMap[weight] || weight,
      style,
      subset
    ].join("-").toLowerCase());
  }
  return [...slugs];
}
function registerFont(path) {
  const slugs = generateSlugs(path);
  for (const slug of slugs) {
    providerContext.registry[slug] ||= [];
    providerContext.registry[slug].push(path);
  }
}
function unregisterFont(path) {
  const slugs = generateSlugs(path);
  for (const slug of slugs) {
    providerContext.registry[slug] ||= [];
    providerContext.registry[slug] = providerContext.registry[slug].filter((p) => p !== path);
  }
}
const extensionPriority = ["woff2", "woff", "ttf", "otf", "eot"];
function lookupFont(family, suffixes) {
  const slug = [fontFamilyToSlug(family), ...suffixes].join("-");
  const paths = providerContext.registry[slug];
  if (!paths || paths.length === 0) {
    return [];
  }
  const fonts = /* @__PURE__ */ new Set();
  for (const path of paths) {
    const base = providerContext.rootPaths.find((root) => path.startsWith(root));
    fonts.add(base ? withLeadingSlash(relative(base, path)) : path);
  }
  return [...fonts].sort((a, b) => {
    const extA = filename(a).split(".").pop();
    const extB = filename(b).split(".").pop();
    return extensionPriority.indexOf(extA) - extensionPriority.indexOf(extB);
  });
}
function fontFamilyToSlug(family) {
  return family.toLowerCase().replace(NON_WORD_RE, "");
}

function generateFontFace(family, font) {
  return [
    "@font-face {",
    `  font-family: '${family}';`,
    `  src: ${renderFontSrc(font.src)};`,
    `  font-display: ${font.display || "swap"};`,
    font.unicodeRange && `  unicode-range: ${font.unicodeRange};`,
    font.weight && `  font-weight: ${font.weight};`,
    font.style && `  font-style: ${font.style};`,
    font.featureSettings && `  font-feature-settings: ${font.featureSettings};`,
    font.variationSettings && `  font-variation-settings: ${font.variationSettings};`,
    `}`
  ].filter(Boolean).join("\n");
}
async function generateFontFallbacks(family, data, fallbacks) {
  if (!fallbacks?.length)
    return [];
  const metrics = await getMetricsForFamily(family);
  if (!metrics)
    return [];
  const css = [];
  for (const fallback of fallbacks) {
    css.push(generateFontFace$1(metrics, {
      ...fallback,
      metrics: await getMetricsForFamily(fallback.font) || void 0
    }));
  }
  return css;
}
const formatMap = {
  woff2: "woff2",
  woff: "woff",
  otf: "opentype",
  ttf: "truetype",
  eot: "embedded-opentype",
  svg: "svg"
};
const formatPriorityList = Object.values(formatMap);
const extensionMap = Object.fromEntries(Object.entries(formatMap).map(([key, value]) => [value, key]));
const formatToExtension = (format) => format && format in extensionMap ? "." + extensionMap[format] : void 0;
function parseFont(font) {
  if (font.startsWith("/") || hasProtocol(font)) {
    const extension = extname(font).slice(1);
    const format = formatMap[extension];
    return {
      url: font,
      format
    };
  }
  return { name: font };
}
function renderFontSrc(sources) {
  return sources.map((src) => {
    if ("url" in src) {
      let rendered = `url("${src.url}")`;
      for (const key of ["format", "tech"]) {
        if (key in src) {
          rendered += ` ${key}(${src[key]})`;
        }
      }
      return rendered;
    }
    return `local("${src.name}")`;
  }).join(", ");
}

const extractableKeyMap = {
  src: "src",
  "font-display": "display",
  "font-weight": "weight",
  "font-style": "style",
  "font-feature-settings": "featureSettings",
  "font-variations-settings": "variationSettings",
  "unicode-range": "unicodeRange"
};
function extractFontFaceData(css) {
  const fontFaces = [];
  for (const node of findAll(parse(css), (node2) => node2.type === "Atrule" && node2.name === "font-face")) {
    if (node.type !== "Atrule" || node.name !== "font-face") {
      continue;
    }
    const data = {};
    for (const child of node.block?.children || []) {
      if (child.type !== "Declaration") {
        continue;
      }
      if (child.property in extractableKeyMap) {
        const value = extractCSSValue(child);
        data[extractableKeyMap[child.property]] = child.property === "src" && !Array.isArray(value) ? [value] : value;
      }
    }
    fontFaces.push(data);
  }
  return mergeFontSources(fontFaces);
}
function extractCSSValue(node) {
  if (node.value.type == "Raw") {
    return [node.value.value];
  }
  const values = [];
  let buffer = "";
  for (const child of node.value.children) {
    if (child.type === "Function") {
      if (child.name === "local" && child.children.first?.type === "String") {
        values.push({ name: child.children.first.value });
      }
      if (child.name === "format" && child.children.first?.type === "String") {
        values.at(-1).format = child.children.first.value;
      }
      if (child.name === "tech" && child.children.first?.type === "String") {
        values.at(-1).tech = child.children.first.value;
      }
    }
    if (child.type === "Url") {
      values.push({ url: child.value });
    }
    if (child.type === "Identifier") {
      buffer = buffer ? `${buffer} ${child.name}` : child.name;
    }
    if (child.type === "String") {
      values.push(child.value);
    }
    if (child.type === "Operator" && child.value === "," && buffer) {
      values.push(buffer);
      buffer = "";
    }
    if (child.type === "UnicodeRange") {
      values.push(child.value);
    }
    if (child.type === "Number") {
      values.push(Number(child.value));
    }
  }
  if (buffer) {
    values.push(buffer);
  }
  if (values.length === 1) {
    return values[0];
  }
  return values;
}
const _genericCSSFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui",
  "ui-serif",
  "ui-sans-serif",
  "ui-monospace",
  "ui-rounded",
  "emoji",
  "math",
  "fangsong"
];
const genericCSSFamilies = new Set(_genericCSSFamilies);
const globalCSSValues = /* @__PURE__ */ new Set([
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
]);
function extractGeneric(node) {
  if (node.value.type == "Raw") {
    return;
  }
  for (const child of node.value.children) {
    if (child.type === "Identifier" && genericCSSFamilies.has(child.name)) {
      return child.name;
    }
  }
}
function extractEndOfFirstChild(node) {
  if (node.value.type == "Raw") {
    return;
  }
  for (const child of node.value.children) {
    if (child.type === "String") {
      return child.loc.end.offset;
    }
    if (child.type === "Operator" && child.value === ",") {
      return child.loc.start.offset;
    }
  }
  return node.value.children.last.loc.end.offset;
}
function extractFontFamilies(node) {
  if (node.value.type == "Raw") {
    return [node.value.value];
  }
  const families = [];
  let buffer = "";
  for (const child of node.value.children) {
    if (child.type === "Identifier" && !genericCSSFamilies.has(child.name) && !globalCSSValues.has(child.name)) {
      buffer = buffer ? `${buffer} ${child.name}` : child.name;
    }
    if (buffer && child.type === "Operator" && child.value === ",") {
      families.push(buffer);
      buffer = "";
    }
    if (child.type === "String") {
      families.push(child.value);
    }
  }
  if (buffer) {
    families.push(buffer);
  }
  return families;
}
function mergeFontSources(data) {
  const mergedData = [];
  for (const face of data) {
    const keys = Object.keys(face).filter((k) => k !== "src");
    const existing = mergedData.find((f) => Object.keys(f).length === keys.length + 1 && keys.every((key) => f[key]?.toString() === face[key]?.toString()));
    if (existing) {
      existing.src.push(...face.src);
    } else {
      mergedData.push(face);
    }
  }
  for (const face of mergedData) {
    face.src.sort((a, b) => {
      const aIndex = "format" in a ? formatPriorityList.indexOf(a.format || "woff2") : -2;
      const bIndex = "format" in b ? formatPriorityList.indexOf(b.format || "woff2") : -2;
      return aIndex - bIndex;
    });
  }
  return mergedData;
}
function addLocalFallbacks(fontFamily, data) {
  for (const face of data) {
    if (face.src[0] && !("name" in face.src[0])) {
      face.src.unshift({ name: fontFamily });
    }
  }
  return data;
}

const storage = createStorage({
  driver: fsDriver({
    base: "node_modules/.cache/nuxt/fonts/meta"
  })
});
async function cachedData(key, fetcher, options) {
  const cached = await storage.getItem(key);
  if (!cached || cached.expires < Date.now()) {
    try {
      const data = await fetcher();
      await storage.setItem(key, { expires: Date.now() + (options?.ttl || 1e3 * 60 * 60 * 24 * 7), data });
      return data;
    } catch (err) {
      if (options?.onError) {
        return options.onError(err);
      }
      throw err;
    }
  }
  return cached.data;
}

const logger = useLogger("@nuxt/fonts");

const google = {
  async setup() {
    await initialiseFontMeta$2();
  },
  async resolveFontFaces(fontFamily, defaults) {
    if (!isGoogleFont(fontFamily)) {
      return;
    }
    return {
      fonts: await cachedData(`google:${fontFamily}-${hash(defaults)}-data.json`, () => getFontDetails$2(fontFamily, defaults), {
        onError(err) {
          logger.error(`Could not fetch metadata for \`${fontFamily}\` from \`google\`.`, err);
          return [];
        }
      })
    };
  }
};
let fonts$2;
async function fetchFontMetadata() {
  return await $fetch("https://fonts.google.com/metadata/fonts").then((r) => r.familyMetadataList);
}
async function initialiseFontMeta$2() {
  fonts$2 = await cachedData("google:meta.json", fetchFontMetadata, {
    onError() {
      logger.error("Could not download `google` font metadata. `@nuxt/fonts` will not be able to inject `@font-face` rules for google.");
      return [];
    }
  });
}
function isGoogleFont(family) {
  return fonts$2.some((font) => font.family === family);
}
const styleMap = {
  italic: "1",
  oblique: "1",
  normal: "0"
};
async function getFontDetails$2(family, variants) {
  const font = fonts$2.find((font2) => font2.family === family);
  const styles = [...new Set(variants.styles.map((i) => styleMap[i]))].sort();
  const variableWeight = font.axes.find((a) => a.tag === "wght");
  const weights = variableWeight ? [`${variableWeight.min}..${variableWeight.max}`] : variants.weights.filter((weight) => String(weight) in font.fonts);
  if (weights.length === 0 || styles.length === 0)
    return [];
  const resolvedVariants = weights.flatMap((w) => [...styles].map((s) => `${s},${w}`)).sort();
  let css = "";
  for (const extension in userAgents) {
    css += await $fetch("/css2", {
      baseURL: "https://fonts.googleapis.com",
      headers: { "user-agent": userAgents[extension] },
      query: {
        family: family + ":ital,wght@" + resolvedVariants.join(";")
      }
    });
  }
  return addLocalFallbacks(family, extractFontFaceData(css));
}
const userAgents = {
  woff2: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
  ttf: "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.54.16 (KHTML, like Gecko) Version/5.1.4 Safari/534.54.16"
  // eot: 'Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)',
  // woff: 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:27.0) Gecko/20100101 Firefox/27.0',
  // svg: 'Mozilla/4.0 (iPad; CPU OS 4_0_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/4.1 Mobile/9A405 Safari/7534.48.3',
};

const bunny = {
  async setup() {
    await initialiseFontMeta$1();
  },
  async resolveFontFaces(fontFamily, defaults) {
    if (!isBunnyFont(fontFamily)) {
      return;
    }
    return {
      fonts: await cachedData(`bunny:${fontFamily}-${hash(defaults)}-data.json`, () => getFontDetails$1(fontFamily, defaults), {
        onError(err) {
          logger.error(`Could not fetch metadata for \`${fontFamily}\` from \`bunny\`.`, err);
          return [];
        }
      })
    };
  }
};
const fontAPI$1 = $fetch.create({
  baseURL: "https://fonts.bunny.net"
});
let fonts$1;
const familyMap = /* @__PURE__ */ new Map();
async function initialiseFontMeta$1() {
  fonts$1 = await cachedData("bunny:meta.json", () => fontAPI$1("/list", { responseType: "json" }), {
    onError() {
      logger.error("Could not download `bunny` font metadata. `@nuxt/fonts` will not be able to inject `@font-face` rules for bunny.");
      return {};
    }
  });
  for (const id in fonts$1) {
    familyMap.set(fonts$1[id].familyName, id);
  }
}
function isBunnyFont(family) {
  return familyMap.has(family);
}
async function getFontDetails$1(family, variants) {
  const id = familyMap.get(family);
  const font = fonts$1[id];
  const weights = variants.weights.filter((weight) => font.weights.includes(Number(weight)));
  const styleMap = {
    italic: "i",
    oblique: "i",
    normal: ""
  };
  const styles = new Set(variants.styles.map((i) => styleMap[i]));
  if (weights.length === 0 || styles.size === 0)
    return [];
  const resolvedVariants = weights.flatMap((w) => [...styles].map((s) => `${w}${s}`));
  const css = await fontAPI$1("/css", {
    query: {
      family: id + ":" + resolvedVariants.join(",")
    }
  });
  return addLocalFallbacks(family, extractFontFaceData(css));
}

const fontshare = {
  async setup() {
    await initialiseFontMeta();
  },
  async resolveFontFaces(fontFamily, defaults) {
    if (!isFontshareFont(fontFamily)) {
      return;
    }
    return {
      fonts: await cachedData(`fontshare:${fontFamily}-${hash(defaults)}-data.json`, () => getFontDetails(fontFamily, defaults), {
        onError(err) {
          logger.error(`Could not fetch metadata for \`${fontFamily}\` from \`fontshare\`.`, err);
          return [];
        }
      })
    };
  }
};
const fontAPI = $fetch.create({
  baseURL: "https://api.fontshare.com/v2"
});
let fonts;
const families = /* @__PURE__ */ new Set();
async function initialiseFontMeta() {
  fonts = await cachedData("fontshare:meta.json", async () => {
    const fonts2 = [];
    let offset = 0;
    let chunk;
    do {
      chunk = await fontAPI("/fonts", {
        query: {
          offset,
          limit: 100
        }
      });
      fonts2.push(...chunk.fonts);
      offset++;
    } while (chunk.has_more);
    return fonts2;
  }, {
    onError() {
      logger.error("Could not download `fontshare` font metadata. `@nuxt/fonts` will not be able to inject `@font-face` rules for fontshare.");
      return [];
    }
  });
  for (const font of fonts) {
    families.add(font.name);
  }
}
function isFontshareFont(family) {
  return families.has(family);
}
async function getFontDetails(family, variants) {
  const font = fonts.find((f) => f.name === family);
  const numbers = [];
  for (const style of font.styles) {
    if (style.is_italic && !variants.styles.includes("italic")) {
      continue;
    }
    if (!variants.weights.includes(style.weight.number)) {
      continue;
    }
    numbers.push(style.weight.number);
  }
  if (numbers.length === 0)
    return [];
  const css = await fontAPI(`/css?f[]=${font.slug + "@" + numbers.join(",")}`);
  return addLocalFallbacks(family, extractFontFaceData(css));
}

const SKIP_RE = /\/node_modules\/(vite-plugin-vue-inspector)\//;
const FontFamilyInjectionPlugin = (options) => createUnplugin(() => {
  async function transformCSS(code) {
    const s = new MagicString(code);
    const injectedDeclarations = /* @__PURE__ */ new Set();
    const promises = [];
    async function addFontFaceDeclaration(fontFamily, fallbackOptions) {
      const result = await options.resolveFontFace(fontFamily, {
        generic: fallbackOptions?.generic,
        fallbacks: fallbackOptions?.fallbacks || []
      }) || {};
      if (!result.fonts)
        return;
      const fallbackMap = result.fallbacks?.map((f) => ({ font: f, name: `${fontFamily} Fallback: ${f}` })) || [];
      let insertFontFamilies = false;
      for (const font of result.fonts) {
        const fallbackDeclarations = await generateFontFallbacks(fontFamily, font, fallbackMap);
        const declarations = [generateFontFace(fontFamily, font), ...fallbackDeclarations];
        for (let declaration of declarations) {
          if (!injectedDeclarations.has(declaration)) {
            injectedDeclarations.add(declaration);
            if (!options.dev) {
              declaration = await transform(declaration, {
                loader: "css",
                charset: "utf8",
                minify: true
              }).then((r) => r.code || declaration).catch(() => declaration);
            } else {
              declaration += "\n";
            }
            s.prepend(declaration);
          }
        }
        if (fallbackDeclarations.length) {
          insertFontFamilies = true;
        }
      }
      if (fallbackOptions && insertFontFamilies) {
        const insertedFamilies = fallbackMap.map((f) => `"${f.name}"`).join(", ");
        s.prependLeft(fallbackOptions.index, `, ${insertedFamilies}`);
      }
    }
    const ast = parse(code, { positions: true });
    const existingFontFamilies = /* @__PURE__ */ new Set();
    walk(ast, {
      visit: "Declaration",
      enter(node) {
        if (this.atrule?.name === "font-face" && node.property === "font-family") {
          for (const family of extractFontFamilies(node)) {
            existingFontFamilies.add(family);
          }
        }
      }
    });
    walk(ast, {
      visit: "Declaration",
      enter(node) {
        if (node.property !== "font-family" || this.atrule?.name === "font-face") {
          return;
        }
        const [fontFamily, ...fallbacks] = extractFontFamilies(node);
        if (fontFamily && !existingFontFamilies.has(fontFamily)) {
          promises.push(addFontFaceDeclaration(fontFamily, node.value.type !== "Raw" ? {
            fallbacks,
            generic: extractGeneric(node),
            index: extractEndOfFirstChild(node)
          } : void 0));
        }
      }
    });
    await Promise.all(promises);
    return s;
  }
  return {
    name: "nuxt:fonts:font-family-injection",
    transformInclude(id) {
      return isCSS(id) && !SKIP_RE.test(id);
    },
    async transform(code) {
      if (!code.includes("font-family:")) {
        return;
      }
      const s = await transformCSS(code);
      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: s.generateMap({ hires: true })
        };
      }
    },
    vite: {
      async generateBundle(_outputOptions, bundle) {
        for (const key in bundle) {
          const chunk = bundle[key];
          if (chunk?.type === "asset" && isCSS(chunk.fileName)) {
            const s = await transformCSS(chunk.source.toString());
            if (s.hasChanged()) {
              chunk.source = s.toString();
            }
          }
        }
      }
    }
  };
});
const IS_CSS_RE = /\.(?:css|scss|sass|postcss|pcss|less|stylus|styl)(\?[^.]+)?$/;
function isCSS(id) {
  return IS_CSS_RE.test(id);
}

function setupPublicAssetStrategy(options = {}) {
  const assetsBaseURL = options.prefix || "/_fonts";
  const nuxt = useNuxt();
  const renderedFontURLs = /* @__PURE__ */ new Map();
  function normalizeFontData(faces) {
    const data = [];
    for (const face of Array.isArray(faces) ? faces : [faces]) {
      data.push({
        ...face,
        src: (Array.isArray(face.src) ? face.src : [face.src]).map((src) => {
          const source = typeof src === "string" ? parseFont(src) : src;
          if ("url" in source && hasProtocol(source.url, { acceptRelative: true })) {
            source.url = source.url.replace(/^\/\//, "https://");
            const file = [
              filename(source.url.replace(/\?.*/, "")),
              hash(source) + (extname(source.url) || formatToExtension(source.format) || "")
            ].filter(Boolean).join("-");
            renderedFontURLs.set(file, source.url);
            source.url = joinURL(assetsBaseURL, file);
          }
          return source;
        })
      });
    }
    return data;
  }
  addDevServerHandler({
    route: assetsBaseURL,
    handler: lazyEventHandler(async () => {
      return eventHandler(async (event) => {
        const filename2 = event.path.slice(1);
        const url = renderedFontURLs.get(event.path.slice(1));
        if (!url) {
          throw createError({ statusCode: 404 });
        }
        const key = "data:fonts:" + filename2;
        let res = await storage.getItemRaw(key);
        if (!res) {
          res = await fetch(url).then((r) => r.arrayBuffer()).then((r) => Buffer.from(r));
          await storage.setItemRaw(key, res);
        }
        return res;
      });
    })
  });
  if (nuxt.options.dev) {
    nuxt.options.routeRules ||= {};
    nuxt.options.routeRules[joinURL(assetsBaseURL, "**")] = {
      cache: {
        maxAge: ONE_YEAR_IN_SECONDS
      }
    };
  }
  nuxt.options.nitro.publicAssets ||= [];
  const cacheDir = join(nuxt.options.buildDir, "cache", "fonts");
  nuxt.options.nitro.publicAssets.push();
  nuxt.options.nitro = defu(nuxt.options.nitro, {
    publicAssets: [{
      dir: cacheDir,
      maxAge: ONE_YEAR_IN_SECONDS,
      baseURL: assetsBaseURL
    }],
    prerender: {
      ignore: [assetsBaseURL]
    }
  });
  const storage = createStorage(fsDriver$1({
    base: "node_modules/.cache/nuxt/fonts"
  }));
  nuxt.hook("nitro:init", async (nitro) => {
    if (nuxt.options.dev) {
      return;
    }
    nitro.hooks.hook("rollup:before", async () => {
      await fsp.rm(cacheDir, { recursive: true, force: true });
      await fsp.mkdir(cacheDir, { recursive: true });
      let banner = false;
      for (const [filename2, url] of renderedFontURLs) {
        const key = "data:fonts:" + filename2;
        let res = await storage.getItemRaw(key);
        if (!res) {
          if (!banner) {
            banner = true;
            logger.info("Downloading fonts...");
          }
          logger.log(chalk.gray("  \u251C\u2500 " + url));
          res = await fetch(url).then((r) => r.arrayBuffer()).then((r) => Buffer.from(r));
          await storage.setItemRaw(key, res);
        }
        await fsp.writeFile(join(cacheDir, filename2), res);
      }
      if (banner) {
        logger.success("Fonts downloaded and cached.");
      }
    });
  });
  return { normalizeFontData };
}
const ONE_YEAR_IN_SECONDS = 60 * 60 * 24 * 365;

const defaultValues = {
  weights: [400],
  styles: ["normal", "italic"],
  subsets: [
    "cyrillic-ext",
    "cyrillic",
    "greek-ext",
    "greek",
    "vietnamese",
    "latin-ext",
    "latin"
  ],
  fallbacks: {
    "serif": ["Times New Roman"],
    "sans-serif": ["Arial"],
    "monospace": ["Courier New"],
    "cursive": [],
    "fantasy": [],
    "system-ui": [
      "BlinkMacSystemFont",
      "Segoe UI",
      "Roboto",
      "Helvetica Neue",
      "Arial"
    ],
    "ui-serif": ["Times New Roman"],
    "ui-sans-serif": ["Arial"],
    "ui-monospace": ["Courier New"],
    "ui-rounded": [],
    "emoji": [],
    "math": [],
    "fangsong": []
  }
};
const module = defineNuxtModule({
  meta: {
    name: "@nuxt/fonts",
    configKey: "fonts"
  },
  defaults: {
    defaults: {},
    assets: {
      prefix: "/_fonts"
    },
    local: {},
    google: {},
    providers: {
      local,
      google,
      bunny,
      fontshare
    }
  },
  async setup(options, nuxt) {
    if (nuxt.options._prepare)
      return;
    const normalizedDefaults = {
      weights: options.defaults?.weights || defaultValues.weights,
      styles: options.defaults?.styles || defaultValues.styles,
      subsets: options.defaults?.subsets || defaultValues.subsets,
      fallbacks: Object.fromEntries(Object.entries(defaultValues.fallbacks).map(([key, value]) => [
        key,
        Array.isArray(options.defaults?.fallbacks) ? options.defaults.fallbacks : options.defaults?.fallbacks?.[key] || value
      ]))
    };
    if (!options.defaults?.fallbacks || !Array.isArray(options.defaults.fallbacks)) {
      const fallbacks = options.defaults.fallbacks ||= {};
      for (const _key in defaultValues.fallbacks) {
        const key = _key;
        fallbacks[key] ||= defaultValues.fallbacks[key];
      }
    }
    const providers = await resolveProviders(options.providers);
    const prioritisedProviders = /* @__PURE__ */ new Set();
    nuxt.hook("modules:done", async () => {
      await nuxt.callHook("fonts:providers", providers);
      const setups = [];
      for (const key in providers) {
        const provider = providers[key];
        if (options.providers?.[key] === false || options.provider && options.provider !== key) {
          delete providers[key];
        } else if (provider.setup) {
          setups.push(provider.setup(options[key] || {}, nuxt));
        }
      }
      await Promise.all(setups);
      for (const val of options.priority || []) {
        if (val in providers)
          prioritisedProviders.add(val);
      }
      for (const provider in providers) {
        prioritisedProviders.add(provider);
      }
    });
    const { normalizeFontData } = setupPublicAssetStrategy(options.assets);
    async function resolveFontFaceWithOverride(fontFamily, override, fallbackOptions) {
      const fallbacks = override?.fallbacks || normalizedDefaults.fallbacks[fallbackOptions?.generic || "sans-serif"];
      if (override && "src" in override) {
        return {
          fallbacks,
          fonts: normalizeFontData({
            src: override.src,
            display: override.display,
            weight: override.weight,
            style: override.style
          })
        };
      }
      if (override?.provider === "none") {
        return;
      }
      const defaults = { ...normalizedDefaults, fallbacks };
      for (const key of ["weights", "styles", "subsets"]) {
        if (override?.[key]) {
          defaults[key] = override[key];
        }
      }
      if (override?.provider) {
        if (override.provider in providers) {
          const result = await providers[override.provider].resolveFontFaces(fontFamily, defaults);
          const fonts = normalizeFontData(result?.fonts || []);
          if (!fonts.length || !result) {
            return logger.warn(`Could not produce font face declaration from \`${override.provider}\` for font family \`${fontFamily}\`.`);
          }
          return {
            fallbacks: result.fallbacks || defaults.fallbacks,
            // Rewrite font source URLs to be proxied/local URLs
            fonts: normalizeFontData(result.fonts)
          };
        }
        logger.warn(`Unknown provider \`${override.provider}\` for font family \`${fontFamily}\`. Falling back to default providers.`);
      }
      for (const key of prioritisedProviders) {
        const provider = providers[key];
        if (provider.resolveFontFaces) {
          const result = await provider.resolveFontFaces(fontFamily, defaults);
          if (result) {
            const fonts = normalizeFontData(result.fonts);
            if (fonts.length > 0) {
              return {
                fallbacks: result.fallbacks || defaults.fallbacks,
                fonts
              };
            }
            if (override) {
              logger.warn(`Could not produce font face declaration for \`${fontFamily}\` with override.`);
            }
          }
        }
      }
    }
    nuxt.options.css.push("#build/nuxt-fonts-global.css");
    addTemplate({
      filename: "nuxt-fonts-global.css",
      write: true,
      // Seemingly necessary to allow vite to process file ðŸ¤”
      async getContents() {
        let css = "";
        for (const family of options.families || []) {
          if (!family.global)
            continue;
          const result = await resolveFontFaceWithOverride(family.name, family);
          for (const font of result?.fonts || []) {
            css += generateFontFace(family.name, font) + "\n";
          }
        }
        return css;
      }
    });
    addBuildPlugin(FontFamilyInjectionPlugin({
      dev: nuxt.options.dev,
      async resolveFontFace(fontFamily, fallbackOptions) {
        const override = options.families?.find((f) => f.name === fontFamily);
        if (override?.global) {
          return;
        }
        return resolveFontFaceWithOverride(fontFamily, override, fallbackOptions);
      }
    }));
  }
});
async function resolveProviders(_providers = {}) {
  const nuxt = useNuxt();
  const _jiti = jiti(nuxt.options.rootDir, { interopDefault: true });
  const providers = { ..._providers };
  for (const key in providers) {
    const value = providers[key];
    if (value === false) {
      delete providers[key];
    }
    if (typeof value === "string") {
      providers[key] = await _jiti(await resolvePath(resolveAlias(value)));
    }
  }
  return providers;
}

export { module as default };
