var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// src/parser.ts
import yargsParser from "yargs-parser";

// src/yars_config.ts
var yarsConfig = {
  "camel-case-expansion": false,
  "combine-arrays": true,
  "short-option-groups": true,
  "dot-notation": false,
  "parse-numbers": true,
  "parse-positional-numbers": false,
  "boolean-negation": true,
  "flatten-duplicate-arrays": true,
  "greedy-arrays": false,
  "strip-aliased": true,
  "nargs-eats-options": false,
  "unknown-options-as-args": false
};

// src/parser.ts
var Parser = class {
  /**
   * Parser options
   */
  #options;
  constructor(options) {
    this.#options = options;
  }
  /**
   * Parsers flags using yargs
   */
  #parseFlags(argv) {
    return yargsParser(argv, { ...this.#options.flagsParserOptions, configuration: yarsConfig });
  }
  /**
   * Scans for unknown flags in yargs output.
   */
  #scanUnknownFlags(parsed) {
    const unknownFlags = [];
    for (let key of Object.keys(parsed)) {
      if (!this.#options.flagsParserOptions.all.includes(key)) {
        unknownFlags.push(key);
      }
    }
    return unknownFlags;
  }
  /**
   * Parsers arguments by mimic