{"version":3,"sources":["../../../src/code_transformer/main.ts","../../../src/code_transformer/rc_file_transformer.ts"],"sourcesContent":["/*\n * @adonisjs/assembler\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { join } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { installPackage, detectPackageManager } from '@antfu/install-pkg'\nimport {\n  Node,\n  Project,\n  QuoteKind,\n  SourceFile,\n  SyntaxKind,\n  CodeBlockWriter,\n  FormatCodeSettings,\n} from 'ts-morph'\n\nimport { RcFileTransformer } from './rc_file_transformer.js'\nimport type { MiddlewareNode, EnvValidationNode, BouncerPolicyNode } from '../types.js'\n\n/**\n * This class is responsible for updating\n */\nexport class CodeTransformer {\n  /**\n   * Exporting utilities to install package and detect\n   * the package manager\n   */\n  installPackage = installPackage\n  detectPackageManager = detectPackageManager\n\n  /**\n   * Directory of the adonisjs project\n   */\n  #cwd: URL\n\n  /**\n   * The TsMorph project\n   */\n  project: Project\n\n  /**\n   * Settings to use when persisting files\n   */\n  #editorSettings: FormatCodeSettings = {\n    indentSize: 2,\n    convertTabsToSpaces: true,\n    trimTrailingWhitespace: true,\n    ensureNewLineAtEndOfFile: true,\n    indentStyle: 2,\n    // @ts-expect-error SemicolonPreference doesn't seem to be re-exported from ts-morph\n    semicolons: 'remove',\n  }\n\n  constructor(cwd: URL) {\n    this.#cwd = cwd\n    this.project = new Project({\n      tsConfigFilePath: join(fileURLToPath(this.#cwd), 'tsconfig.json'),\n      manipulationSettings: { quoteKind: QuoteKind.Single },\n    })\n  }\n\n  /**\n   * Add a new middleware to the middleware array of the\n   * given file\n   */\n  #addToMiddlewareArray(file: SourceFile, target: string, middlewareEntry: MiddlewareNode) {\n    const callExpressions = file\n      .getDescendantsOfKind(SyntaxKind.CallExpression)\n      .filter((statement) => statement.getExpression().getText() === target)\n\n    if (!callExpressions.length) {\n      throw new Error(`Cannot find ${target} statement in the file.`)\n    }\n\n    const arrayLiteralExpression = callExpressions[0].getArguments()[0]\n    if (!arrayLiteralExpression || !Node.isArrayLiteralExpression(arrayLiteralExpression)) {\n      throw new Error(`Cannot find middleware array in ${target} statement.`)\n    }\n\n    const middleware = `() => import('${middlewareEntry.path}')`\n\n    /**\n     * Delete the existing middleware if it exists\n     */\n    const existingMiddlewareIndex = arrayLiteralExpression\n      .getElements()\n      .findIndex((element) => element.getText() === middleware)\n\n    if (existingMiddlewareIndex === -1) {\n      /**\n       * Add the middleware to the top or bottom of the array\n       */\n      if (middlewareEntry.position === 'before') {\n        arrayLiteralExpression.insertElement(0, middleware)\n      } else {\n        arrayLiteralExpression.addElement(middleware)\n      }\n    }\n  }\n\n  /**\n   * Add a new middleware to the named middleware of the given file\n   */\n  #addToNamedMiddleware(file: SourceFile, middlewareEntry: MiddlewareNode) {\n    if (!middlewareEntry.name) {\n      throw new Error('Named middleware requires a name.')\n    }\n\n    const callArguments = file\n      .getVariableDeclarationOrThrow('middleware')\n      .getInitializerIfKindOrThrow(SyntaxKind.CallExpression)\n      .getArguments()\n\n    if (callArguments.length === 0) {\n      throw new Error('Named middleware call has no arguments.')\n    }\n\n    const namedMiddlewareObject = callArguments[0]\n    if (!Node.isObjectLiteralExpression(namedMiddlewareObject)) {\n      throw new Error('The argument of the named middleware call is not an object literal.')\n    }\n\n    /**\n     * Check if property is already defined. If so, remove it\n     */\n    const existingProperty = namedMiddlewareObject.getProperty(middlewareEntry.name)\n    if (!existingProperty) {\n      /**\n       * Add the named middleware\n       */\n      const middleware = `${middlewareEntry.name}: () => import('${middlewareEntry.path}')`\n      namedMiddlewareObject!.insertProperty(0, middleware)\n    }\n  }\n\n  /**\n   * Add a policy to the list of pre-registered policy\n   */\n  #addToPoliciesList(file: SourceFile, policyEntry: BouncerPolicyNode) {\n    const policiesObject = file\n      .getVariableDeclarationOrThrow('policies')\n      .getInitializerIfKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n\n    /**\n     * Only define policy when one with the existing name does not\n     * exist.\n     */\n    const existingProperty = policiesObject.getProperty(policyEntry.name)\n    if (!existingProperty) {\n      const policy = `${policyEntry.name}: () => import('${policyEntry.path}')`\n      policiesObject!.insertProperty(0, policy)\n    }\n  }\n\n  /**\n   * Add the given import declarations to the source file\n   * and merge named imports with the existing import\n   */\n  #addImportDeclarations(\n    file: SourceFile,\n    importDeclarations: { isNamed: boolean; module: string; identifier: string }[]\n  ) {\n    const existingImports = file.getImportDeclarations()\n\n    importDeclarations.forEach((importDeclaration) => {\n      const existingImport = existingImports.find(\n        (mod) => mod.getModuleSpecifierValue() === importDeclaration.module\n      )\n\n      /**\n       * Add a new named import to existing import for the\n       * same module\n       */\n      if (existingImport && importDeclaration.isNamed) {\n        if (\n          !existingImport\n            .getNamedImports()\n            .find((namedImport) => namedImport.getName() === importDeclaration.identifier)\n        ) {\n          existingImport.addNamedImport(importDeclaration.identifier)\n        }\n        return\n      }\n\n      /**\n       * Ignore default import when the same module is already imported.\n       * The chances are the existing default import and the importDeclaration\n       * identifiers are not the same. But we should not modify existing source\n       */\n      if (existingImport) {\n        return\n      }\n\n      file.addImportDeclaration({\n        ...(importDeclaration.isNamed\n          ? { namedImports: [importDeclaration.identifier] }\n          : { defaultImport: importDeclaration.identifier }),\n        moduleSpecifier: importDeclaration.module,\n      })\n    })\n  }\n\n  /**\n   * Write a leading comment\n   */\n  #addLeadingComment(writer: CodeBlockWriter, comment?: string) {\n    if (!comment) {\n      return writer.blankLine()\n    }\n\n    return writer\n      .blankLine()\n      .writeLine('/*')\n      .writeLine(`|----------------------------------------------------------`)\n      .writeLine(`| ${comment}`)\n      .writeLine(`|----------------------------------------------------------`)\n      .writeLine(`*/`)\n  }\n\n  /**\n   * Add new env variable validation in the\n   * `env.ts` file\n   */\n  async defineEnvValidations(definition: EnvValidationNode) {\n    /**\n     * Get the `start/env.ts` source file\n     */\n    const kernelUrl = fileURLToPath(new URL('./start/env.ts', this.#cwd))\n    const file = this.project.getSourceFileOrThrow(kernelUrl)\n\n    /**\n     * Get the `Env.create` call expression\n     */\n    const callExpressions = file\n      .getDescendantsOfKind(SyntaxKind.CallExpression)\n      .filter((statement) => statement.getExpression().getText() === 'Env.create')\n\n    if (!callExpressions.length) {\n      throw new Error(`Cannot find Env.create statement in the file.`)\n    }\n\n    const objectLiteralExpression = callExpressions[0].getArguments()[1]\n    if (!Node.isObjectLiteralExpression(objectLiteralExpression)) {\n      throw new Error(`The second argument of Env.create is not an object literal.`)\n    }\n\n    let shouldAddComment = true\n\n    /**\n     * Add each variable validation\n     */\n    for (const [variable, validation] of Object.entries(definition.variables)) {\n      /**\n       * Check if the variable is already defined. If so, remove it\n       */\n      const existingProperty = objectLiteralExpression.getProperty(variable)\n\n      /**\n       * Do not add leading comment if one or more properties\n       * already exists\n       */\n      if (existingProperty) {\n        shouldAddComment = false\n      }\n\n      /**\n       * Add property only when the property does not exist\n       */\n      if (!existingProperty) {\n        objectLiteralExpression.addPropertyAssignment({\n          name: variable,\n          initializer: validation,\n          leadingTrivia: (writer) => {\n            if (!shouldAddComment) {\n              return\n            }\n\n            shouldAddComment = false\n            return this.#addLeadingComment(writer, definition.leadingComment)\n          },\n        })\n      }\n    }\n\n    file.formatText(this.#editorSettings)\n    await file.save()\n  }\n\n  /**\n   * Define new middlewares inside the `start/kernel.ts`\n   * file\n   *\n   * This function is highly based on some assumptions\n   * and will not work if you significantly tweaked\n   * your `start/kernel.ts` file.\n   */\n  async addMiddlewareToStack(stack: 'server' | 'router' | 'named', middleware: MiddlewareNode[]) {\n    /**\n     * Get the `start/kernel.ts` source file\n     */\n    const kernelUrl = fileURLToPath(new URL('./start/kernel.ts', this.#cwd))\n    const file = this.project.getSourceFileOrThrow(kernelUrl)\n\n    /**\n     * Process each middleware entry\n     */\n    for (const middlewareEntry of middleware) {\n      if (stack === 'named') {\n        this.#addToNamedMiddleware(file, middlewareEntry)\n      } else {\n        this.#addTo